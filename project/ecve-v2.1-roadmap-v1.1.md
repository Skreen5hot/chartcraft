# ECVE v2.1 Implementation Roadmap v1.1

## Document Status

| Field | Value |
|---|---|
| Governing Spec | ECVE v2.1 FINAL |
| Roadmap Version | 1.1 |
| Supersedes | Roadmap v1.0 |
| Status | Planning |
| Date | 2026-02-21 |

## Change Summary from v1.0

| Risk | Fix | Affected Features |
|---|---|---|
| Combinatorial Starvation — sequential shape iteration exhausts 500-cap before reaching later chart types | Quota-Based Allocation replaces global cap. Per-shape ceiling with diversity guarantee. | F4.5, F5 (all), F1.6 (retrofitted) |
| Data Lineage Mutation — normalizer destructively mutates raw CSV, breaking audit hashes | Immutable Raw Buffer + Derived Column architecture. Normalizer appends, never overwrites. | F1.2, F3.1, F6.6 |
| SVG DOM Explosion — 10,000-node scatter plot locks the main thread | Rendering threshold heuristic with Canvas degradation for live preview, SVG deferred to export. | F6.4, F1.8 |
| Unidirectional Data Flow — UI could bypass JSON-LD state and mutate Vega-Lite directly | Strict dispatch-only architecture mandated for customization panel. | F2.4 |
| Histogram Binning Passthrough — Vega-Lite creates computed fields that don't exist in the schema | Compiler handles binning as a mark-level directive, not a field-level schema extension. | F5.4 |

---

## Roadmap Structure

This roadmap is organized into six phases. Each phase produces a working, testable increment of the system. No phase depends on future phases — each milestone is shippable on its own.

Every feature listed here will be decomposed into its own implementation plan. This document provides only enough detail to scope the work and point to the governing spec section.

---

## Architectural Invariant: Immutable Raw Buffer

This invariant applies across all phases and is not scoped to a single feature. It is listed here as a cross-cutting concern.

**Rule:** The raw CSV byte buffer ingested in Phase 1 is IMMUTABLE from the moment it enters the pipeline. No pipeline phase may modify, overwrite, or discard the original bytes. The raw buffer is stored alongside the state graph (as a binary blob in IndexedDB or a file on disk) and is referenced by SHA-256 hash in the `viz:DatasetSchema` via `viz:rawInputHash`.

All transformations — normalization, type inference, derived columns — operate on a **working copy**. The working copy is a separate in-memory data structure that carries provenance metadata linking every transformation back to the raw source.

This invariant guarantees that:
- The audit log (Phase 6, F6.6) can verify pipeline reproducibility by re-hashing the original input.
- A `.jsonld` state export paired with the original CSV can reproduce the exact pipeline from scratch.
- No normalizer bug can silently corrupt the user's source data.

**Spec Reference:** Sections 3.2, 6.1, 1.1 (Determinism Contract)

---

## Phase 1 — Foundation: Ingestion, Inference, and the Bar Chart

**Goal:** End-to-end pipeline for one chart type. A user drops a CSV and gets a bar chart SVG. This phase proves the architecture works.

### F1.1 — CSV Parser & Structural Validator
- RFC 4180-compliant CSV parser (UTF-8)
- Detect and halt on: malformed quoting, encoding errors, zero data rows, zero columns
- Write `err:ParseFailure` to state graph on failure
- Store raw byte buffer as immutable artifact; compute and record SHA-256 hash
- **Spec Reference:** Section 6.1 (Step 1)
- **Acceptance Criteria:**
  - Parser handles quoted fields, embedded commas, embedded newlines per RFC 4180
  - Malformed CSV produces a valid `err:ParseFailure` JSON-LD entity (not a thrown exception)
  - Zero-row and zero-column CSVs are caught and produce distinct error entities
  - Raw byte buffer is persisted separately and its SHA-256 hash is recorded on the `viz:DatasetSchema`
  - No downstream pipeline phase holds a mutable reference to the raw buffer

### F1.2 — Pre-Processing Normalizer (Non-Destructive)
- Operates on a **working copy** of the parsed data, never the raw buffer
- BOM stripping (on working copy)
- Trailing empty column removal
- Currency/formatting stripping per Appendix A.6
- For every normalized cell, the normalizer records a provenance entry: `{ originalValue, normalizedValue, transformationType }`
- Normalization metadata (`viz:wasNormalized`, `viz:wasPercentage`) attached to resulting fields
- Locale-aware date conversion deferred to Phase 3
- **Spec Reference:** Section 6.1 (Step 0), Appendix A.6, Architectural Invariant (Immutable Raw Buffer)
- **Acceptance Criteria:**
  - `"$1,234.56"` normalizes to `"1234.56"` on the working copy; raw buffer still contains `"$1,234.56"`
  - `"45%"` normalizes to `"45"` with `viz:wasPercentage: true`
  - Normalization is idempotent (applying twice to the working copy produces same result)
  - Columns that are 100% empty across all rows are stripped from the working copy
  - Provenance entries are queryable: given a normalized value, the original raw value can be retrieved
  - SHA-256 hash of the raw buffer is unchanged after normalization completes

### F1.3 — Type Inferencer (Deterministic)
- 100-row bounded inspection window
- Regex cascade: Temporal → Boolean → Integer → Float → Nominal (Appendix A.1–A.5)
- Numeric Unification before consensus (Integer + Float merged before threshold check)
- 95% consensus threshold with `viz:NominalType` fallback
- `err:InferenceUncertainty` written for sub-threshold columns
- Output: `viz:DatasetSchema` JSON-LD graph with `viz:rawInputHash` linking to immutable source
- **Spec Reference:** Section 6.1 (Steps 2a–2e), Appendix A.1–A.5
- **Acceptance Criteria:**
  - Column `[100, 42.50, 15, 99.99, 200, 1.5]` infers as `viz:QuantitativeType` (not Nominal) — the numeric consensus bug is dead
  - Column `["US", "UK", "US", "DE", 42]` (96% Nominal) infers as `viz:NominalType`
  - Column with 80% Integer, 12% Float, 8% strings → unified numeric = 92% < 95% → falls back to Nominal with `err:InferenceUncertainty`
  - Two independent implementations using the normative regexes produce byte-identical `viz:DatasetSchema` for the same input
  - Empty cells are excluded from consensus denominator
  - `viz:rawInputHash` on the schema matches the SHA-256 of the persisted raw buffer

### F1.4 — State Graph Manager
- JSON-LD state graph with `bones:conformsToSpec: "bones:ecve/2.1"`
- IndexedDB adapter (browser), filesystem adapter (Node.js)
- State accepts and returns only JSON-LD
- Error accumulation (non-blocking errors persist in graph alongside valid data)
- Raw buffer stored in a separate IndexedDB object store (not inline in JSON-LD) referenced by hash
- **Spec Reference:** Sections 1.2, 3.2, 4.2 (Error Accumulation Rule)
- **Acceptance Criteria:**
  - State graph round-trips through serialize → persist → load → deserialize with zero data loss
  - Version declaration present on every serialized graph
  - Multiple `err:InferenceUncertainty` entities coexist with valid `viz:DataField` entities in the same graph
  - Raw buffer can be retrieved by its SHA-256 hash from the storage adapter

### F1.5 — SHACL Validation Engine
- Load and evaluate `viz:BarChartSpecificationShape` with `sh:closed true`
- Validate candidate subgraphs (binary pass/fail)
- Return structured `sh:ValidationReport` on failure
- Safely ignore `viz:requiresFieldType` (Custom Reasoner Directive)
- **Spec Reference:** Sections 5.1, 5.2, 5.3, 9.1
- **Acceptance Criteria:**
  - A conforming bar chart spec passes validation
  - A spec with an extraneous triple fails due to `sh:closed true`
  - A spec with `viz:aggregate` set to a string literal (instead of a `viz:AggregateOperation` IRI) fails validation
  - `viz:requiresFieldType` triples on the shape do not cause validation errors

### F1.6 — Reasoner: Bar Chart Candidate Generation (Quota-Aware)
- Shape registry with `viz:BarChartSpecificationShape` (1 Nominal, 1 Quantitative)
- Arity pre-filtering against `viz:DatasetSchema`
- Permutation generation (all valid Nominal × Quantitative field assignments)
- **Quota-Based Allocation** (forward-compatible with Phases 4–5):
  - Even in Phase 1 with a single shape, the Reasoner implements the quota architecture so it does not need to be retrofitted later
  - Per-shape quota: `floor(globalCap / registeredShapeCount)` with remainder distributed round-robin by shape priority
  - Phase 1: 1 registered shape → quota = 500 (functionally identical to a global cap, but the algorithm is already quota-based)
  - When quota is exceeded for a shape, candidates are ranked by a field-quality heuristic (prefer columns with fewer empty cells, prefer lower column index as tiebreaker)
- SHACL validation of each candidate
- `err:NoViableCandidate` on empty result set
- `viz:CandidateTruncation` written when any shape's quota is exceeded, recording: shape IRI, total combinatorial space, quota applied, candidates emitted
- **Spec Reference:** Section 6.2
- **Acceptance Criteria:**
  - A dataset with 3 Nominal and 2 Quantitative columns produces 6 bar chart candidates (3 × 2)
  - A dataset with 0 Nominal columns produces zero candidates and an `err:NoViableCandidate` entity
  - All candidates pass SHACL validation independently
  - The Reasoner internally uses quota allocation even with a single shape (verified by unit test that inspects allocation logic)
  - A dataset with 25 Nominal and 25 Quantitative columns (625 permutations) triggers `viz:CandidateTruncation` at the 500 quota boundary

### F1.7 — Compiler: Vega-Lite Projection (Bar Chart)
- Load `proj:` graph for Vega-Lite target
- Dot-notation path resolver per Section 6.4.1
- `proj:PropertyMapping` traversal
- `proj:SubgraphMapping` traversal with child mappings
- `proj:iriToValue` resolution for mark types and aggregate operations
- `proj:optional` handling (skip silently)
- `err:CompilationFailure` on missing non-optional properties
- Append `$schema` to output
- **Spec Reference:** Sections 6.4.1, 6.4.2, 6.4.3, 9.2
- **Acceptance Criteria:**
  - The example state graph from Section 9.3 compiles to the exact Vega-Lite JSON shown in the spec
  - `"encoding.x"` produces `{"encoding": {"x": {...}}}` — never a flat key
  - `viz:SumOp` IRI resolves to `"sum"` string via the projection graph's `proj:iriToValue`
  - Missing non-optional property produces `err:CompilationFailure` (not a thrown exception)
  - Path collision (segment already exists as non-object) produces `err:CompilationFailure`

### F1.8 — Renderer: SVG Output (With Threshold Awareness)
- Vega-Lite runtime integration (browser and Node.js)
- SVG DOM string output (Tier 1 deterministic)
- PNG export via Canvas (Tier 2 lossy, browser) or `canvas` npm module (Node.js)
- **Mark count estimator:** Before rendering, the renderer estimates the unaggregated mark count from the spec and dataset row count. This is a forward-compatible hook for the rendering threshold heuristic in Phase 6.
  - Phase 1: The estimator is implemented but the threshold is not enforced (bar charts aggregate, so mark counts are always low)
  - The estimator interface is defined now so Phase 6 can activate it without refactoring
- **Spec Reference:** Section 6.5, Section 1.1
- **Acceptance Criteria:**
  - Same Vega-Lite JSON produces byte-identical SVG strings across two runs on the same machine
  - SVG output is valid XML parseable by any XML parser
  - PNG export produces a downloadable image file
  - Browser and Node.js both produce valid SVG from the same Vega-Lite input
  - Mark count estimator returns a count for any given spec + row count (even if the threshold is not enforced yet)

### Phase 1 Milestone Acceptance
> A user drops a two-column CSV (one Nominal, one Quantitative) into the system. The pipeline infers types, generates bar chart candidates via quota-based allocation, the user (or a default selection) picks one, the compiler produces Vega-Lite JSON, and the renderer outputs an SVG. The entire state is captured as a JSON-LD file that can be exported, emailed, and re-loaded on another machine to reproduce the identical SVG. The raw CSV buffer is persisted immutably alongside the state graph, and its SHA-256 hash matches the `viz:rawInputHash` on the schema. All failures produce `err:` entities in the graph. No thrown exceptions escape the pipeline.

---

## Phase 2 — UI: The Excel Bridge

**Goal:** A functional browser UI that non-technical users can operate. The gap between "I have a spreadsheet" and "I have a chart" is closed for bar charts.

### F2.1 — CSV Drop Zone
- Drag-and-drop file ingestion
- File picker fallback
- Clipboard paste (copy from spreadsheet → paste into ECVE)
- Immediate display of file name, row count, column count before inference completes
- **Spec Reference:** Section 7.2
- **Acceptance Criteria:**
  - Files dragged from desktop are accepted and parsed
  - File picker opens and accepts `.csv` files
  - Pasted tab-delimited text from Excel clipboard is accepted and converted
  - File metadata (name, rows, columns) displays within 200ms of drop, before type inference finishes

### F2.2 — Type Review Panel
- Per-column display: name, inferred type, consensus score, sample values
- Yellow highlight on columns with `err:InferenceUncertainty`
- Manual type override dropdown on uncertain columns
- Override triggers state graph update and Reasoner re-run
- Normalization indicator on fields where `viz:wasNormalized: true`
- **Spec Reference:** Section 7.3
- **Acceptance Criteria:**
  - Every column from the `viz:DatasetSchema` is displayed with its inferred type
  - Columns with consensus < 0.95 show a visual warning and override control
  - Changing a column type from Nominal to Quantitative triggers new candidate generation
  - Currency-stripped fields show a "Formatting removed" indicator

### F2.3 — Chart Selection Gallery
- Thumbnail previews of valid candidates (rendered from first 20 rows)
- Grouped by chart type
- Pre-selection of highest-ranked candidate
- `err:NoViableCandidate` messaging
- **Spec Reference:** Section 7.4
- **Acceptance Criteria:**
  - Only SHACL-validated candidates appear in the gallery
  - Thumbnails render actual data, not placeholder graphics
  - Zero-candidate state shows explanatory message with suggestions
  - Selecting a candidate updates the state graph and advances to customization

### F2.4 — Customization Panel (Unidirectional Data Flow)
- Title input (free text)
- Color picker / preset palette
- Sort order toggle (asc/desc)
- Aggregation dropdown (only valid `viz:AggregateOperation` individuals)
- **Strict Unidirectional Data Flow:** The UI MUST NOT mutate the Vega-Lite JSON directly. Every user interaction dispatches a mutation to the JSON-LD state graph. The state graph mutation triggers SHACL validation. If validation passes, the state graph is updated, which triggers a recompile via the Compiler, which produces new Vega-Lite JSON, which triggers a re-render. The UI reads the rendered output; it never writes to the compilation target.

  ```
  UI Event → JSON-LD Mutation → SHACL Gate → State Graph → Compiler → Vega-Lite → Renderer → UI Display
                                    ↑                                                              |
                                    └──────────── NEVER a direct path ─────────────────────────────┘
  ```

- `err:ValidationFailure` displayed inline with control revert
- **Spec Reference:** Sections 7.5, 6.3
- **Acceptance Criteria:**
  - Changing the title updates the live preview via the full recompile pipeline (state → compile → render), not via direct Vega-Lite mutation
  - Invalid mutations are rejected, the control reverts, and a human-readable error message appears
  - Axis type, encoding channel, and mark type controls are NOT exposed
  - Aggregation dropdown shows only Sum, Mean, Count, Min, Max, Median — no free text
  - No code path exists that writes to the Vega-Lite JSON object without going through the JSON-LD state graph (verified by code review / architectural test)

### F2.5 — Export Panel
- SVG download button
- PNG download button (configurable DPI, default 150)
- Copy-to-clipboard (PNG) for paste into Excel/PowerPoint
- State export (.jsonld) for session sharing
- **Spec Reference:** Section 7.6
- **Acceptance Criteria:**
  - SVG download produces a valid `.svg` file
  - PNG download produces a raster image at the specified DPI
  - Copy-to-clipboard pastes a valid image into Excel and PowerPoint
  - `.jsonld` export can be re-loaded into ECVE to reproduce the identical visualization

### F2.6 — Error Surfacing Layer
- Read `err:` entities from state graph
- Map error classes to UI severity levels (blocking, warning, inline, informational)
- Blocking errors halt the UI flow with full-screen guidance
- Inline errors flash the offending control
- **Spec Reference:** Section 7.7
- **Acceptance Criteria:**
  - `err:ParseFailure` produces a blocking full-screen message
  - `err:InferenceUncertainty` produces a yellow warning on the affected column
  - `err:ValidationFailure` produces a red flash on the customization control that triggered it
  - `err:CompilationFailure` produces a blocking error with "report this bug" guidance

### Phase 2 Milestone Acceptance
> A non-technical user exports a CSV from Excel containing sales data with currency-formatted revenue and region names. They drag it into ECVE in a browser. The type review panel shows Revenue as Quantitative (with "Currency formatting removed" noted) and Region as Nominal. They see bar chart thumbnails in the gallery, select one, change the title to "Q4 Revenue by Region", and click "Copy to Clipboard." They paste the chart into a PowerPoint slide. Total time from CSV drop to PowerPoint paste: under 60 seconds. At no point does the UI write directly to Vega-Lite JSON — every interaction routes through JSON-LD state → SHACL validation → recompile.

---

## Phase 3 — Visualization Expansion: Line Charts & Temporal Data

**Goal:** Add the line chart visualization type and the full temporal data handling pipeline, including locale-aware date normalization with immutable data lineage.

### F3.1 — Locale-Aware Date Normalizer (Non-Destructive, Derived Column Architecture)
- Implement Appendix A.7 conversion patterns (en-US, en-GB, de-DE, ja-JP)
- UI locale hint selector
- Ambiguity rule enforcement (no conversion without locale or with ambiguous patterns)
- Two-digit year rejection
- **Immutable Lineage:** The normalizer DOES NOT overwrite date values in the working copy. Instead, it appends a **derived column** to the runtime dataset:
  - Original column `Date` (raw values, e.g., `"01/15/2024"`) is preserved in the working copy
  - A new column `Date__ecve_normalized` is appended with ISO 8601 values (e.g., `"2024-01-15"`)
  - The `viz:DatasetSchema` records both fields:
    - `viz:field/date` — the raw column, typed as `viz:NominalType` (because `MM/DD/YYYY` doesn't match the ISO 8601 regex)
    - `viz:field/date__ecve_normalized` — the derived column, typed as `viz:TemporalType`, with `prov:wasDerivedFrom` pointing to `viz:field/date`
  - The Reasoner and Compiler target the derived column for temporal chart types
  - The UI displays the original column name (`Date`) to the user but internally binds to the derived column
- **Spec Reference:** Section 6.1 (Step 0, item 4), Appendix A.7, Architectural Invariant (Immutable Raw Buffer)
- **Acceptance Criteria:**
  - `"01/15/2024"` with `en-US` locale produces a derived column value of `"2024-01-15"` — the original value is unchanged in the working copy
  - `"15/01/2024"` with `en-GB` locale produces a derived column value of `"2024-01-15"`
  - `"01/02/2024"` with no locale hint produces NO derived column (original passes through as-is)
  - `"1/15/25"` (two-digit year) produces NO derived column regardless of locale
  - Derived column has `prov:wasDerivedFrom` linking to the raw field IRI
  - SHA-256 hash of the raw buffer is unchanged after date normalization
  - Converted values in the derived column pass the Temporal regex (Appendix A.1) during type inference

### F3.2 — Ontology Extension: Line Chart
- `viz:LineChartSpecification` class (already declared in 9.1)
- `viz:LineChartSpecificationShape` SHACL shape with `sh:closed true`
  - Requires: `viz:hasMarkType` = `viz:LineMark`, 1 Temporal encoding (X axis), 1 Quantitative encoding (Y axis)
- `viz:requiresFieldType`: 1 Temporal, 1 Quantitative
- `viz:TemporalEncodingShape` sub-shape (maps to `viz:XPositionChannel` for time-series)
- **Spec Reference:** Sections 4.1, 5.2, 9.1 (extension pattern)
- **Acceptance Criteria:**
  - Shape validates a conforming line chart spec
  - Shape rejects a spec using a Nominal field in the temporal slot
  - `sh:closed true` rejects unexpected triples
  - Existing bar chart shapes are unmodified

### F3.3 — Projection Extension: Line Chart → Vega-Lite
- `proj:LineChart_*` mappings in the projection graph
- `viz:LineMark` → `"line"` via `proj:iriToValue`
- `viz:TemporalType` → `"temporal"` via `proj:iriToValue` on channel mapping
- Projection targets the derived column name (e.g., `Date__ecve_normalized`) but the UI displays the original column name via a `proj:displayAlias` property
- **Spec Reference:** Section 9.2 (extension pattern)
- **Acceptance Criteria:**
  - A line chart spec compiles to valid Vega-Lite with `"mark": "line"` and `"type": "temporal"` on the X encoding
  - The `"field"` value in the Vega-Lite output references the derived column when a date conversion occurred
  - Projection graph additions do not modify any existing bar chart mappings

### F3.4 — Reasoner: Line Chart Registration
- Add `viz:LineChartSpecificationShape` to the shape registry
- Arity signature: 1 Temporal, 1 Quantitative
- Reasoner binds to derived temporal columns (those with `prov:wasDerivedFrom`) when matching arity requirements
- Quota allocation now divides across 2 shapes: `floor(500 / 2) = 250` per shape
- **Spec Reference:** Section 6.2
- **Acceptance Criteria:**
  - A dataset with 1 Temporal and 2 Quantitative columns produces 2 line chart candidates
  - A dataset with 0 Temporal columns produces 0 line chart candidates (no error — bar charts may still be viable)
  - Line chart candidates and bar chart candidates coexist in the same output set
  - Per-shape quota is 250 (verified by unit test)

### F3.5 — UI: Mixed Chart Gallery
- Gallery now groups bar charts and line charts separately
- Thumbnail rendering handles temporal X axes (date labels)
- Derived column display: thumbnails show the original column name, not the `__ecve_normalized` suffix
- **Spec Reference:** Section 7.4
- **Acceptance Criteria:**
  - A dataset with both Nominal and Temporal columns produces both bar and line candidates in the gallery
  - Line chart thumbnails render date labels on the X axis
  - Chart type grouping headers are visible ("Bar Charts", "Line Charts")
  - Column names shown in thumbnails use the original user-facing name, not the derived column name

### Phase 3 Milestone Acceptance
> A user drops a CSV with a Date column (`MM/DD/YYYY`) and a Revenue column. They select the `en-US` locale. The normalizer creates a derived temporal column without modifying the raw data. ECVE infers Temporal and Quantitative types on the derived column, generates both bar chart and line chart candidates (quota: 250 each), and the gallery shows both groups. The user selects a line chart, customizes the title, and exports an SVG showing revenue over time. The raw buffer hash is unchanged. The `.jsonld` export includes `prov:wasDerivedFrom` lineage on the derived field.

---

## Phase 4 — Visualization Expansion: Scatter Plots & Multi-Field Charts

**Goal:** Add scatter plots (the first two-Quantitative chart type) and grouped bar charts (the first three-field chart type). These stress-test the Reasoner's quota-based combinatorial generator.

### F4.1 — Ontology Extension: Scatter Plot
- `viz:ScatterSpecification` class (already declared in 9.1)
- `viz:ScatterSpecificationShape` SHACL shape
  - Requires: `viz:hasMarkType` = `viz:PointMark`, 2 Quantitative encodings (X and Y)
- `viz:requiresFieldType`: 2 Quantitative
- `viz:QuantitativeXEncodingShape` and `viz:QuantitativeYEncodingShape` sub-shapes
- **Spec Reference:** Sections 4.1, 5.2
- **Acceptance Criteria:**
  - Shape validates a conforming scatter spec with two distinct Quantitative fields
  - Shape rejects a spec where both encodings reference the same field
  - Existing bar and line shapes are unmodified

### F4.2 — Projection Extension: Scatter Plot → Vega-Lite
- `proj:Scatter_*` mappings
- `viz:PointMark` → `"point"` via `proj:iriToValue`
- Both X and Y encodings map to `"quantitative"`
- **Spec Reference:** Section 9.2 (extension pattern)
- **Acceptance Criteria:**
  - A scatter spec compiles to valid Vega-Lite with `"mark": "point"` and both axes typed `"quantitative"`

### F4.3 — Ontology Extension: Grouped Bar Chart
- `viz:GroupedBarSpecification` class
- `viz:GroupedBarSpecificationShape` SHACL shape
  - Requires: `viz:hasMarkType` = `viz:BarMark`, 1 Nominal (X axis), 1 Nominal (color channel), 1 Quantitative (Y axis)
- `viz:requiresFieldType`: 2 Nominal, 1 Quantitative
- `viz:ColorEncodingShape` sub-shape (maps to `viz:ColorChannel`)
- **Spec Reference:** Sections 4.1, 5.2
- **Acceptance Criteria:**
  - Shape validates a conforming grouped bar spec with two distinct Nominal fields and one Quantitative
  - Shape rejects a spec where both Nominal encodings reference the same field

### F4.4 — Projection Extension: Grouped Bar → Vega-Lite
- `proj:GroupedBar_*` mappings
- Color encoding maps to `encoding.color` with `"type": "nominal"`
- **Spec Reference:** Section 9.2 (extension pattern)
- **Acceptance Criteria:**
  - A grouped bar spec compiles to valid Vega-Lite with `encoding.color` present
  - The output renders a grouped/clustered bar chart in the Vega-Lite runtime

### F4.5 — Reasoner: Quota-Based Allocation (Full Implementation)
- Register Scatter and Grouped Bar shapes alongside Bar and Line
- **Quota-Based Allocation Algorithm:**
  1. **Global cap:** 500 candidates total (unchanged from spec)
  2. **Base quota:** `baseQuota = floor(globalCap / registeredShapeCount)` — with 4 shapes, this is 125 per shape
  3. **Remainder distribution:** `remainder = globalCap mod registeredShapeCount` — distributed one each to shapes ranked by priority (simplest chart types first: Bar → Line → Scatter → Grouped Bar)
  4. **Per-shape generation:** For each shape, the generator produces up to `baseQuota + (1 if shape receives remainder)` candidates. Within the quota, candidates are ranked by field quality:
     - Primary sort: prefer columns with the fewest empty cells in the inspection window
     - Secondary sort: prefer lower column index (leftmost columns first)
  5. **Quota exhaustion entity:** When a shape's combinatorial space exceeds its quota, `viz:CandidateTruncation` is written with: shape IRI, total permutation count, quota applied, candidates actually emitted
  6. **Cross-shape guarantee:** Every shape with at least one satisfiable permutation is guaranteed representation in the output. No shape can be starved by another shape's large combinatorial space.

- **Spec Reference:** Section 6.2
- **Acceptance Criteria:**
  - With 4 registered shapes and globalCap=500: base quota is 125 per shape
  - A dataset with 15 Nominal and 15 Quantitative columns:
    - Bar: 15 × 15 = 225 permutations → capped at 126 (125 base + 1 remainder), `viz:CandidateTruncation` written
    - Line: 0 Temporal → 0 candidates, 0 emitted, quota 125 unused
    - Scatter: P(15,2) = 210 permutations → capped at 125, `viz:CandidateTruncation` written
    - Grouped Bar: P(15,2) × 15 = 3150 permutations → capped at 125, `viz:CandidateTruncation` written
    - **Total emitted: 376** (126 + 0 + 125 + 125), all four types represented
  - Unused quota from shapes with 0 candidates (Line in the above example) is NOT redistributed — the global cap simply isn't reached. This keeps the algorithm simple and deterministic.
  - All candidates pass SHACL validation independently
  - The starvation scenario from the v1.0 critique is impossible: scatter and grouped bar candidates are always generated regardless of how many bar candidates exist

### F4.6 — UI: Gallery Scale & Grouping
- Gallery handles 4 chart type groups
- Scroll/pagination for large candidate sets
- `viz:CandidateTruncation` surfaced as informational message per shape group (e.g., "Showing 125 of 210 possible scatter plots")
- **Spec Reference:** Section 7.4
- **Acceptance Criteria:**
  - Gallery groups: Bar Charts, Line Charts, Scatter Plots, Grouped Bar Charts
  - Per-shape truncation message displays when that shape's quota was exceeded
  - User can browse all groups without UI performance degradation

### Phase 4 Milestone Acceptance
> A user drops a dataset with 6 columns: 2 Nominal, 1 Temporal, 3 Quantitative. The Reasoner generates candidates across all four chart types with quota-based allocation (125 per shape). The gallery shows bar charts, line charts, scatter plots, and grouped bar charts. The user selects a scatter plot, customizes it, and exports SVG. No chart type was starved by another's combinatorial space. Truncation messages appear only for shapes that exceeded their quota.

---

## Phase 5 — Advanced Visualizations & Ontology Expansion

**Goal:** Extend the visualization vocabulary to cover the remaining high-value chart types. Each requires a new ontology class, SHACL shape, projection mapping, and Reasoner registration. With 11 total shapes, the per-shape quota drops to `floor(500/11) = 45`.

### F5.1 — Stacked Bar Chart
- `viz:StackedBarSpecification` — same field arity as Grouped Bar (2 Nominal, 1 Quantitative) but with `viz:stackMode: "stacked"` property
- Shape distinguishes from Grouped Bar via the stack property
- Vega-Lite projection uses `"encoding.color"` with implicit stacking behavior
- **Acceptance Criteria:**
  - Stacked and Grouped bar candidates generated from the same schema
  - Vega-Lite output renders stacked bars (not clustered)
  - Stacked bar is visually distinct from grouped bar in gallery thumbnails

### F5.2 — Area Chart
- `viz:AreaChartSpecification` — same arity as Line Chart (1 Temporal, 1 Quantitative)
- `viz:AreaMark` mark type individual
- Vega-Lite projection: `"mark": "area"`
- **Acceptance Criteria:**
  - Area chart and line chart candidates coexist for the same Temporal × Quantitative schema
  - SVG renders a filled area beneath the line

### F5.3 — Stacked Area Chart
- `viz:StackedAreaSpecification` — 1 Temporal, 1 Nominal (color), 1 Quantitative
- Extension of Area Chart with color encoding
- **Acceptance Criteria:**
  - Stacked area renders multiple filled series distinguished by color
  - Requires 3-field minimum (Temporal + Nominal + Quantitative)

### F5.4 — Histogram (With Vega-Lite Binning Passthrough)
- `viz:HistogramSpecification` — 1 Quantitative (binned on X), Count on Y
- First chart type where the Y axis aggregation is implicit (`viz:CountOp`) rather than user-selected
- **Binning Architecture:** The histogram's binning behavior is expressed as a mark-level directive in the `viz:HistogramSpecification`, NOT as a schema-level field extension. The `viz:DatasetSchema` does not invent synthetic binned fields. Instead:
  - The SHACL shape includes a `viz:hasBinConfig` property (with `viz:maxBins` integer, default 10)
  - The projection mapping translates `viz:hasBinConfig` to Vega-Lite's `"bin": true` (or `"bin": {"maxbins": N}`) on the X encoding
  - Vega-Lite internally creates computed fields (e.g., `bin_maxbins_10_Revenue`) at render time — these are transparent to ECVE
- Bin count is a customizable parameter in the Customization Panel
- **Acceptance Criteria:**
  - A single Quantitative column can produce a histogram (1-field chart type)
  - Y axis is automatically set to Count aggregation
  - `viz:DatasetSchema` contains NO synthetic bin fields — binning is handled entirely in the projection
  - Changing the bin count in the Customization Panel updates `viz:hasBinConfig` in the state graph → recompile → re-render (unidirectional flow)
  - Vega-Lite output contains `"bin": true` or `"bin": {"maxbins": N}` — ECVE does not attempt to pre-bin the data

### F5.5 — Heatmap
- `viz:HeatmapSpecification` — 2 Nominal (X and Y), 1 Quantitative (color intensity)
- `viz:HeatmapMark` mark type
- Vega-Lite projection: `"mark": "rect"` with `encoding.color` as quantitative
- **Acceptance Criteria:**
  - Heatmap renders a grid of colored rectangles
  - Color encoding maps a Quantitative field to a continuous color scale
  - Requires exactly 2 Nominal + 1 Quantitative

### F5.6 — Pie / Donut Chart
- `viz:PieChartSpecification` — 1 Nominal (theta), 1 Quantitative (value)
- Vega-Lite projection: `"mark": {"type": "arc"}` with `encoding.theta` and `encoding.color`
- Same field arity as bar chart; Reasoner generates both
- **Acceptance Criteria:**
  - Pie chart renders as an arc-based chart
  - Candidates coexist with bar charts in the gallery for the same 1 Nominal + 1 Quantitative schema
  - Donut variant available as a customization option (inner radius parameter)

### F5.7 — Bubble Chart
- `viz:BubbleChartSpecification` — 2 Quantitative (X and Y), 1 Quantitative (size)
- Extension of scatter plot with `viz:SizeChannel` encoding
- `viz:requiresFieldType`: 3 Quantitative
- **Acceptance Criteria:**
  - Bubble chart renders as scatter plot with variable-size points
  - Requires 3 distinct Quantitative fields
  - Size legend is displayed

### F5.8 — Quota Rebalancing Verification
- With 11 registered shapes, base quota = `floor(500/11) = 45` per shape
- Verify that all 11 chart types are represented in the candidate output for a sufficiently rich dataset
- Verify that `viz:CandidateTruncation` entities are written per-shape (not globally) with accurate counts
- **Acceptance Criteria:**
  - A dataset with 5 Nominal, 2 Temporal, 6 Quantitative columns produces candidates for all applicable chart types
  - No chart type with satisfiable arity is absent from the output
  - Total candidates ≤ 500
  - Each shape's truncation entity (if any) records the correct total permutation count and applied quota

### Phase 5 Milestone Acceptance
> The system supports 11 chart types: Bar, Grouped Bar, Stacked Bar, Line, Area, Stacked Area, Scatter, Bubble, Histogram, Heatmap, and Pie/Donut. A dataset with 4 Nominal, 1 Temporal, and 5 Quantitative columns produces candidates across all applicable chart types with per-shape quota allocation (45 each). Every chart type has its own SHACL shape, projection mapping, and Reasoner registration. No existing shapes were modified to add any new type. Histogram binning is handled entirely in the projection layer — no synthetic fields in the schema. The gallery handles 11 groups without performance issues.

---

## Phase 6 — Hardening, Portability & Edge Deployment

**Goal:** Production hardening. The system is reliable, portable, and deployable on constrained edges.

### F6.1 — State Graph Portability
- Export `.jsonld` with full provenance (including `prov:wasDerivedFrom` lineage on derived columns)
- Import `.jsonld` and reproduce exact visualization
- Version mismatch detection and `err:VersionMismatch` handling
- Cross-browser state portability testing (Chrome, Firefox, Safari, Edge)
- Optional: bundle raw CSV alongside `.jsonld` for full reproducibility
- **Spec Reference:** Sections 1.2, 7.6
- **Acceptance Criteria:**
  - A `.jsonld` file exported from Chrome on macOS loads in Firefox on Windows and produces byte-identical SVG
  - A state graph with `bones:conformsToSpec: "bones:ecve/2.0"` produces an `err:VersionMismatch` when loaded into the v2.1 runtime (no silent data corruption)
  - Derived column provenance is preserved across export/import

### F6.2 — Node.js CLI
- Headless pipeline: `ecve render --input data.csv --output chart.svg`
- All pipeline phases execute without a browser
- IndexedDB replaced with filesystem adapter
- Vega-Lite headless SVG rendering
- Immutable raw buffer persisted as a file alongside the output
- **Spec Reference:** Sections 3.2, 6.5, 8 (Spec Test Verification)
- **Acceptance Criteria:**
  - `ecve render` produces identical SVG to the browser pipeline for the same input
  - CLI exits with structured error output (JSON) on pipeline failures, not stack traces
  - Runs on Node.js LTS with zero native dependencies beyond the `canvas` module
  - Raw input file is not modified by the CLI

### F6.3 — Offline-First Verification
- Full pipeline audit: zero network calls during any phase
- Service Worker registration for browser caching of the ECVE app shell
- All ontology graphs, projection graphs, and Vega-Lite runtime bundled locally
- **Spec Reference:** Section 8 (Spec Test Verification — "Requires infrastructure? No")
- **Acceptance Criteria:**
  - Browser DevTools Network tab shows zero outbound requests during CSV → SVG pipeline
  - Application loads and functions with airplane mode enabled after initial visit
  - Total bundle size documented and < 5MB

### F6.4 — Performance Benchmarks (With Rendering Threshold)
- Type inference: < 100ms for 100-row × 50-column CSV
- Reasoner: < 500ms for 500-candidate generation and SHACL validation across 11 shapes
- Compilation: < 50ms for any single specification
- Rendering: < 2s for SVG output of 10,000-row dataset
- **Rendering Threshold Heuristic:** Activate the mark count estimator from F1.8:
  - **Aggregated charts** (bar, grouped bar, stacked bar, histogram, heatmap, pie): mark count = estimated unique category combinations. Always below threshold. Render SVG directly.
  - **Unaggregated charts** (scatter, bubble, line, area): mark count ≈ dataset row count.
  - **Threshold: 2,000 marks.**
  - **Below threshold:** Render SVG directly in the main thread (current behavior).
  - **Above threshold — Live Preview:** Render to Canvas element (not SVG) for the interactive preview. Canvas handles 10,000+ marks without DOM explosion.
  - **Above threshold — Export:** SVG generation runs in a Web Worker (browser) or child process (Node.js). The UI shows a progress indicator. The exported SVG is the Tier 1 deterministic output. The Canvas preview is Tier 2.
  - The threshold value (2,000) is configurable via `bones:renderingThreshold` in the state graph.
- **Acceptance Criteria:**
  - All timing benchmarks pass on a mid-range 2024 laptop (8GB RAM, 4-core CPU)
  - A 10,000-row scatter plot renders a Canvas preview in < 2s without freezing the UI
  - The same 10,000-row scatter plot produces an SVG via Web Worker within 10s
  - Aggregated charts (bar, histogram) always render SVG directly regardless of dataset size
  - Benchmark suite is automated and runs in CI

### F6.5 — Accessibility
- SVG output includes ARIA labels derived from `viz:hasTitle` and field names
- Chart gallery thumbnails have descriptive alt text
- Full keyboard navigation through the UI flow
- Color palettes include a colorblind-safe default
- **Acceptance Criteria:**
  - Screen reader can announce the chart title, chart type, and axis labels from the SVG
  - All UI interactions are reachable via Tab/Enter/Escape
  - Default color palette passes WCAG 2.1 AA contrast ratios

### F6.6 — Audit Log (Optional Extension)
- `bones:AuditLog` graph for serializing ephemeral `viz:VisualizationRenderingProcess` entities
- Captures: timestamp, raw input SHA-256 hash, output SVG SHA-256 hash, specification IRI, pipeline phase durations
- Reproducibility verification: given the audit log entry, re-run the pipeline with the stored raw buffer and confirm the output SVG hash matches
- Opt-in configuration (not enabled by default)
- **Spec Reference:** Section 4.1 (Ephemerality Note — "MAY be serialized into a separate bones:AuditLog")
- **Acceptance Criteria:**
  - Audit log entries are valid JSON-LD with `viz:VisualizationRenderingProcess` entities
  - Each entry includes the SHA-256 of the raw input buffer (from `viz:rawInputHash`) and a SHA-256 of the output SVG
  - Re-running the pipeline with the same raw buffer produces an SVG whose hash matches the audit log entry
  - Audit log does not affect pipeline performance when disabled
  - Derived column provenance is traceable: the audit log can reconstruct which normalizations were applied to which raw values

### Phase 6 Milestone Acceptance
> The system passes all spec test verification criteria from Section 8. It runs in the browser and Node.js. It requires zero infrastructure. It is structurally deterministic. State graphs are portable across browsers and operating systems. The CLI produces identical output to the browser. The application loads offline. Performance benchmarks pass on commodity hardware — including 10,000-row scatter plots that render a Canvas preview in < 2s and produce SVG via background worker within 10s. The audit log can verify end-to-end reproducibility by re-hashing the immutable raw buffer against the recorded output hash. The system is accessible to screen readers and keyboard-only users.

---

## Summary: Phase → Chart Type Matrix

| Chart Type | Phase | Arity Signature | Aggregated? |
|---|---|---|---|
| Bar | 1 | 1 Nominal, 1 Quantitative | Yes |
| Line | 3 | 1 Temporal, 1 Quantitative | No |
| Scatter | 4 | 2 Quantitative | No |
| Grouped Bar | 4 | 2 Nominal, 1 Quantitative | Yes |
| Stacked Bar | 5 | 2 Nominal, 1 Quantitative + stack | Yes |
| Area | 5 | 1 Temporal, 1 Quantitative | No |
| Stacked Area | 5 | 1 Temporal, 1 Nominal, 1 Quantitative | No |
| Histogram | 5 | 1 Quantitative | Yes (binned) |
| Heatmap | 5 | 2 Nominal, 1 Quantitative | Yes |
| Pie / Donut | 5 | 1 Nominal, 1 Quantitative | Yes |
| Bubble | 5 | 3 Quantitative | No |

## Summary: Phase → Milestone Focus

| Phase | Focus | Key Deliverable |
|---|---|---|
| 1 | Foundation | End-to-end pipeline for bar charts. Immutable buffer. Quota-ready Reasoner. |
| 2 | UI | Browser interface. Unidirectional data flow. Excel round-trip. |
| 3 | Temporal | Line charts. Derived column architecture. Date lineage. |
| 4 | Multi-field | Scatter & grouped bar. Quota-based allocation proven under load. |
| 5 | Breadth | 7 additional chart types. Histogram binning passthrough. Quota at 45/shape. |
| 6 | Hardening | Offline. Portable. Rendering threshold. Audit log. Accessible. |

## Summary: Cross-Cutting Invariants

| Invariant | Introduced | Verified |
|---|---|---|
| Immutable Raw Buffer (SHA-256 hashed, never mutated) | Phase 1 (F1.1) | Phase 6 (F6.6) |
| Quota-Based Candidate Allocation (no starvation) | Phase 1 (F1.6) | Phase 5 (F5.8) |
| Unidirectional Data Flow (UI → JSON-LD → Compile → Render) | Phase 2 (F2.4) | All subsequent phases |
| Non-Destructive Normalization (derived columns, not overwrites) | Phase 1 (F1.2) | Phase 3 (F3.1) |
| Rendering Threshold (Canvas preview above 2,000 marks) | Phase 1 hook (F1.8) | Phase 6 (F6.4) |
