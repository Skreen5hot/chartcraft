# Edge-Canonical Visualization Engine (ECVE) v2.1 — FINAL

## Specification Status

| Field | Value |
|---|---|
| Version | 2.1 FINAL |
| Status | Release Candidate |
| Supersedes | ECVE v2.0 Draft |
| Ontology Version IRI | `bones:ecve/2.1` |
| Author | FNSR Architecture Team |
| Date | 2026-02-21 |

---

## 0. Design Philosophy — The Excel Gap

### 0.1 The Problem ECVE Solves

There are approximately 750 million Excel users worldwide. The overwhelming majority of them have data they want to visualize. The overwhelming majority of them fail.

Excel's charting workflow requires users to pre-select data ranges, navigate a gallery of chart types they may not understand, manually configure axes, legends, and aggregations, and troubleshoot formatting failures that produce misleading graphs. The cognitive load is enormous. The error rate is high. The result is that most people with data never produce a visualization at all — or produce one that misrepresents the underlying information.

This is not a tooling problem. It is a semantic gap. Excel does not understand what the data *means*. It cannot distinguish a column of country names from a column of product codes without being told. It cannot infer that a column of dollar amounts should be summed rather than averaged without explicit instruction. Every decision that could be automated by understanding the data's semantics is instead pushed onto the user as a manual configuration step.

ECVE closes this gap.

### 0.2 Meeting Users Where They Are

ECVE does not ask users to abandon Excel, learn a programming language, or understand ontologies. The design contract with the user is:

1. **You give us a CSV.** Export from Excel, Google Sheets, a database, a government data portal — the source does not matter. CSV is the universal lowest common denominator.
2. **We understand your data.** The Type Inferencer reads your columns and determines what they are — dates, categories, numbers — without asking you.
3. **We show you what's possible.** The Reasoner evaluates your data against every known chart type and presents only the visualizations that are structurally valid for your data. You cannot accidentally create a chart that misrepresents your information because the ontology forbids it.
4. **You customize what matters.** Titles, colors, sort order. The things a human should decide. Not axis types, not aggregation functions, not encoding channels — those are already correct because the semantic layer handled them.
5. **You get a picture.** An SVG or PNG that you can paste back into your Excel workbook, your PowerPoint, your email, your report.

The user never sees a JSON-LD graph. They never encounter a SHACL shape. They never learn what BFO stands for. The entire ontological machinery exists to make the user's experience feel like the software simply *understands their spreadsheet*.

### 0.3 The Excel Round-Trip

ECVE is explicitly designed to complement spreadsheet workflows, not replace them. The expected usage pattern is:

```
Excel/Sheets → Export CSV → ECVE → SVG/PNG → Paste back into Excel/Sheets/PowerPoint
```

This means ECVE must handle the specific pathologies of spreadsheet-exported CSV files:

- **Mixed numeric formatting.** Excel exports currency columns as `"$1,234.56"` or `"1234.56"` depending on locale and formatting. The Type Inferencer's regex cascade handles unformatted numerics; the Pre-Processing Normalizer (Section 6.1) strips common formatting artifacts before inference begins.
- **Merged cell artifacts.** Excel merged cells export as a value in the first row and empty strings in subsequent rows. The Type Inferencer excludes empty cells from consensus calculation, preventing these from poisoning the type determination.
- **Date format chaos.** Excel serializes dates differently depending on OS locale, Excel version, and cell formatting. The Type Inferencer recognizes only ISO 8601 dates. The Pre-Processing Normalizer attempts to detect and convert common Excel date patterns (`MM/DD/YYYY`, `DD/MM/YYYY`, `M/D/YY`) to ISO 8601 using a locale hint provided by the UI. If conversion is ambiguous (e.g., `01/02/2024` — January 2nd or February 1st?), the normalizer does not guess; it leaves the value as-is and lets the cascade classify it as Nominal, triggering an `err:InferenceUncertainty` that the UI can surface as a date format prompt.
- **Trailing empty columns.** Spreadsheet exports often include phantom columns from unused formatted cells. The ingestion layer strips any column where 100% of inspected cells are empty.

### 0.4 Why Not Just Improve Excel?

Excel is a general-purpose computation environment. Its charting subsystem must support arbitrary use cases, which means it cannot make strong assumptions about data semantics. ECVE is a single-purpose visualization tool. It trades generality for intelligence. Because it does only one thing — turn tabular data into correct charts — it can embed deep domain knowledge about what makes a visualization semantically valid.

The philosophical position is: **the user's data already knows what chart it should be.** The ontology's job is to listen.

---

## 1. Architectural Posture

ECVE is a pure-function transformation pipeline. It accepts raw tabular data, lifts it into a semantic JSON-LD graph, validates that graph against SHACL-enforced BFO-aligned shapes, compiles the result to a rendering grammar, and projects a visual artifact. It requires zero network infrastructure. The system state is entirely captured by a single, versioned, canonical JSON-LD graph.

### 1.1 Determinism Contract

HTML5 Canvas text rendering depends on host OS font metrics and anti-aliasing algorithms. Pixel-perfect PNG determinism across heterogeneous edges is therefore mathematically impossible.

ECVE v2.1 defines two tiers of output determinism:

**Tier 1 — Structural Determinism (Guaranteed):** Given the same input CSV and the same ontology graph, ECVE will produce the exact same Vega-Lite AST and the exact same SVG XML structure, byte-for-byte, regardless of host environment. The SVG DOM string is the canonical deterministic output of the pipeline.

**Tier 2 — Environmental Projection (Best-Effort):** PNG and raster exports are classified as Lossy Environmental Projections. They are handled by the Integration layer and are explicitly excluded from the determinism contract. Two edges running identical inputs will produce visually similar but not byte-identical PNGs.

### 1.2 Ontology Versioning

Every serialized ECVE state graph MUST include a version declaration at its root:

```json
{
  "@id": "bones:ecve/state/current",
  "@type": "bones:StateGraph",
  "bones:conformsToSpec": "bones:ecve/2.1"
}
```

A future ECVE runtime encountering a state graph with `bones:conformsToSpec: "bones:ecve/2.0"` MUST either migrate the graph forward or reject it with an `err:VersionMismatch` error entity. Migration strategies are outside the scope of this specification but MUST be deterministic pure functions.

---

## 2. Namespace Governance

ECVE v2.1 eliminates all placeholder namespaces. Four governed namespaces partition concerns:

| Prefix | IRI | Scope |
|---|---|---|
| `bones:` | `https://fnsr.org/ontology/bones/` | Foundational execution architecture |
| `viz:` | `https://fnsr.org/ontology/ecve/viz/` | Domain visualization ontology (classes, properties, individuals) |
| `proj:` | `https://fnsr.org/ontology/ecve/proj/` | Compiler projection mappings (decoupled from SHACL) |
| `err:` | `https://fnsr.org/ontology/ecve/err/` | Error and uncertainty ontology |

**Governance Rule:** No class, property, or individual in the ECVE ontology may use an unregistered namespace. The `ex:` prefix is prohibited in all production artifacts.

### 2.1 Namespace Separation Principle

The `proj:` namespace is stored in a **separate named graph** from the SHACL validation shapes. This enables:

- A generic SHACL validator to process the validation graph with zero awareness of projection concerns.
- Independent versioning of projection targets. Adding a new compilation target (e.g., Observable Plot) requires only a new projection graph — the validation graph is untouched.
- Clean tooling boundaries. Validation tools read `viz:` and SHACL. Compiler tools read `viz:` and `proj:`. Neither needs the other's auxiliary namespace.

The projection graph references SHACL shape IRIs but does not annotate them. It is a standalone mapping document.

---

## 3. Separation of Concerns

### 3.1 Computation (Core Logic)

Deterministic pure functions. Given the same CSV string and the same ontology graph, these functions will always produce the exact same SVG output.

- **Pre-Processing Normalizer:** `Raw CSV String` → `Clean CSV String` (formatting artifacts stripped)
- **Type Inferencer:** `Clean CSV String` → `viz:DatasetSchema` (JSON-LD)
- **Reasoner:** `viz:DatasetSchema` + `Ontology (SHACL)` → `Candidate Specs[]` (JSON-LD)
- **Compiler:** `viz:VisualizationSpecification` (JSON-LD) + `Projection Graph` (JSON-LD) → `Vega-Lite Grammar` (JSON)

### 3.2 State (Pluggable)

The absolute state of the application is a single JSON-LD document containing the parsed dataset schema, the chosen visualization specification, and any error entities. The state graph MUST include a `bones:conformsToSpec` declaration.

- **Adapter:** IndexedDB (Browser) or local file system (Node.js).
- **Rule:** The state adapter only accepts and returns JSON-LD. It performs no transformation.

### 3.3 Orchestration (Pluggable)

The event loop that invokes computation.

- **Adapter:** Browser DOM events (button clicks, file drops) or Node.js CLI arguments.

### 3.4 Integration (Pluggable)

I/O operations interfacing with the host environment.

- **Adapters:** HTML5 `FileReader` API (CSV input), SVG DOM serialization (canonical output), HTML5 `<canvas>` API (lossy PNG export).

---

## 4. Ontological Architecture

### 4.1 Realist Ontology (BFO/CCO Alignment)

All domain classes are grounded in Basic Formal Ontology (BFO) and Common Core Ontologies (CCO). The following commitments are normative.

**`viz:VisualizationSpecification`** subclasses `cco:DirectiveInformationContentEntity`. It is an information artifact that prescribes how a rendering process must behave. It is not a description of data; it is a directive to an agent.

**`viz:DataEncoding`** subclasses `cco:DirectiveInformationContentEntity`. A data encoding prescribes the mapping of a data field to a visual channel. It is directive, not descriptive.

**`viz:VisualChannel`** and its subclasses (`viz:XPositionChannel`, `viz:YPositionChannel`, `viz:ColorChannel`, `viz:SizeChannel`) subclass `cco:InformationContentEntity`. They are abstract descriptions of visual dimensions, not directives.

**`viz:AggregateOperation`** subclasses `cco:InformationContentEntity`. Concrete aggregate operations are named individuals, not string literals:

- `viz:SumOp` — Sum aggregation
- `viz:MeanOp` — Arithmetic mean aggregation
- `viz:CountOp` — Count aggregation
- `viz:MinOp` — Minimum value
- `viz:MaxOp` — Maximum value
- `viz:MedianOp` — Median value

SHACL shapes reference these individuals via `sh:hasValue` or `sh:in`, never via string matching.

**`viz:VisualizationRenderingProcess`** subclasses `bfo:BFO_0000015` (Process). The ontology asserts that instances of `viz:VisualizationRenderingProcess` stand in a `bfo:realizes` relationship to instances of `viz:VisualizationSpecification`. This closes the BFO realization pattern: a directive entity is realized by the process it directs.

**Ephemerality Note:** `viz:VisualizationRenderingProcess` instances are Occurrents — events that happen in time. They occur during Phase 5 (Rendering) but are NOT serialized into the `bones:StateGraph`. The state graph captures only Continuants (Information Entities that persist across time). Process entities are ephemeral runtime artifacts. They MAY be serialized into a separate `bones:AuditLog` graph if the system is configured for execution tracing, but this is outside the scope of the core specification.

**`viz:DataType`** subclasses `cco:InformationContentEntity`. Concrete types are named individuals:

- `viz:QuantitativeType`
- `viz:NominalType`
- `viz:TemporalType`
- `viz:BooleanType`
- `viz:UnknownType` — Assigned when the Type Inferencer cannot reach consensus.

### 4.2 Error Ontology

Errors are first-class citizens of the JSON-LD state graph. When a failure occurs, the pipeline writes an error entity into the graph rather than throwing a transient exception. All error classes subclass `err:ECVEError`, which itself subclasses `cco:InformationContentEntity`.

| Error Class | Trigger | Required Properties |
|---|---|---|
| `err:ParseFailure` | CSV input is malformed (encoding errors, structural violations, zero rows) | `err:rawInput` (truncated), `err:failureReason` |
| `err:InferenceUncertainty` | Type Inferencer cannot reach consensus threshold for a column | `err:fieldName`, `err:candidateTypes[]`, `err:consensusScore` |
| `err:NoViableCandidate` | Reasoner generates zero valid visualization specifications | `err:schemaRef` (IRI of the DatasetSchema), `err:evaluatedShapeCount` |
| `err:ValidationFailure` | SHACL validation rejects a state mutation | `err:shapeRef` (IRI of the failing shape), `err:resultMessage`, `err:focusNode` |
| `err:CompilationFailure` | Valid graph cannot be compiled to target grammar (ontology bug safeguard) | `err:specRef` (IRI of the spec), `err:compilerMessage` |
| `err:VersionMismatch` | State graph declares a `bones:conformsToSpec` that the runtime does not support | `err:declaredVersion`, `err:supportedVersions[]` |

**Error Accumulation Rule:** Errors do not halt the pipeline unless they occur in a phase that blocks all downstream computation (e.g., `err:ParseFailure` blocks everything). Non-blocking errors (e.g., `err:InferenceUncertainty` on one column) are accumulated in the graph, and the pipeline continues with degraded output. The UI layer reads error entities from the graph and surfaces them to the user.

---

## 5. SHACL Architecture

### 5.1 Strict Closure

All SHACL node shapes are declared with `sh:closed true`. The `sh:ignoredProperties` list includes `rdf:type`, `rdfs:label`, and `rdfs:comment`. Any triple on a focus node that is not covered by an explicit `sh:property` declaration and is not in the ignored set will cause a validation failure. This guarantees that the compiler never encounters unexpected state.

### 5.2 Polymorphic Targeting

Each visualization type has its own SHACL shape subclass with a locked type identifier. For example, `viz:BarChartSpecificationShape` constrains `viz:hasMarkType` to the single value `viz:BarMark`. This is an intentional design pattern. Adding a new chart type (e.g., line chart, scatter plot) requires:

1. A new `viz:` class (e.g., `viz:LineChartSpecification`) subclassing `viz:VisualizationSpecification`.
2. A new SHACL shape (e.g., `viz:LineChartSpecificationShape`) with its own `sh:in` constraint on `viz:hasMarkType`.
3. A new projection mapping entry in the `proj:` graph.
4. Registration in the Reasoner's shape registry (Section 6.2).

No existing shapes are modified.

### 5.3 Custom Reasoner Directives

The `viz:requiresFieldType` property attached to SHACL node shapes is a **Custom Reasoner Directive**. It is not part of the SHACL vocabulary. Standard SHACL validation engines will safely ignore it because it falls outside the `sh:` namespace and is not referenced by any `sh:property` path. It exists exclusively for the combinatorial generator (Section 6.2) to read during arity pre-filtering. This is an intentional extension point: the SHACL shapes carry domain metadata for the Reasoner without polluting the validation semantics.

### 5.4 Projection Decoupling

The projection graph is a separate JSON-LD document that maps SHACL shape IRIs and property paths to target grammar output paths. It does not annotate SHACL nodes; it references them.

Structure of a projection mapping entry:

```json
{
  "@id": "proj:BarChart_hasMarkType",
  "@type": "proj:PropertyMapping",
  "proj:sourceShape": { "@id": "viz:BarChartSpecificationShape" },
  "proj:sourceProperty": { "@id": "viz:hasMarkType" },
  "proj:targetPath": "mark.type",
  "proj:targetType": "string"
}
```

This design means:

- The SHACL validation graph contains zero projection metadata.
- The projection graph can be versioned, swapped, or extended independently.
- Supporting a second compilation target (e.g., Observable Plot) requires only a second projection graph, with zero changes to the validation layer.

---

## 6. The Deterministic Pipeline

### 6.1 Phase 1 — Ingestion & Type Inference

**Input:** A CSV file (UTF-8 encoded) provided via DOM FileReader or Node.js `fs.readFileSync`.

**Step 0 — Pre-Processing Normalization:**

Before type inference, the raw CSV undergoes deterministic normalization to handle common spreadsheet export artifacts. The normalizer applies the following transformations in order:

1. **Strip BOM:** Remove UTF-8 Byte Order Mark (`\xEF\xBB\xBF`) if present.
2. **Trailing Column Removal:** Drop any column where 100% of cells (across all rows, not just the inspection window) are empty.
3. **Currency/Formatting Stripping:** For each cell value, apply the normative stripping regex (Appendix A.6): remove leading currency symbols (`$`, `€`, `£`, `¥`), thousands separators (`,` when followed by exactly three digits), and trailing percentage signs. This transforms `"$1,234.56"` to `"1234.56"` and `"45%"` to `"45"`. The stripping is recorded as metadata (`viz:wasNormalized: true`) on the resulting `viz:DataField` so the UI can inform the user.
4. **Locale-Aware Date Conversion (Optional):** If the UI provides a locale hint (e.g., `en-US`), the normalizer attempts to convert common date patterns to ISO 8601. The normative conversion patterns are defined in Appendix A.7. If conversion is ambiguous (e.g., `01/02/2024` in an unknown locale), the value is left as-is. This step is **optional** — if no locale hint is provided, it is skipped entirely.

**Step 1 — Structural Validation:**

1. Parse with a standards-compliant CSV parser (RFC 4180).
2. If parsing fails (malformed quoting, encoding errors, zero data rows after header), write an `err:ParseFailure` entity to the state graph and halt the pipeline.
3. If the CSV has zero columns after trailing column removal, write `err:ParseFailure` and halt.

**Step 2 — Type Inference Algorithm (Deterministic):**

The Type Inferencer is a **contract**, not an assertion. Downstream pipeline phases trust its output unconditionally. Data rows beyond the inspection window are the user's responsibility. This is documented in the UI as: *"ECVE inspects the first 100 rows to determine column types."*

The algorithm:

**2a. Bounding:** Read the header row and exactly the first `N = min(100, total_data_rows)` data rows.

**2b. Per-Column Regex Cascade:** For each column, evaluate every non-empty cell value against the following regex cascade, in order. The first match wins for that cell.

| Priority | Type | Normative Regex (ECMA-262) |
|---|---|---|
| 1 | Temporal | See Appendix A.1 |
| 2 | Boolean | See Appendix A.2 |
| 3 | Integer | See Appendix A.3 |
| 4 | Float | See Appendix A.4 |
| 5 | Nominal | Everything else (default fallback) — See Appendix A.5 |

**Notes on the cascade:**
- Temporal is tested first because date strings like `"2024-01-15"` would otherwise match neither Float nor Integer but could be misclassified by a less strict parser.
- Boolean is tested before numeric types because `"true"` and `"false"` are not numbers.
- Integer is tested before Float because `"42"` should be classified as Integer, not as a Float lacking a decimal point.
- The 15-digit limit on numeric types prevents misclassification of long ID strings (e.g., credit card numbers) as numbers.
- Empty cells are excluded from all calculations.

**2c. Numeric Unification (CRITICAL — applied BEFORE consensus):** Before computing the consensus threshold, the algorithm unifies Integer and Float matches into a single Numeric super-category. For each column, compute:

```
numericCount = count(Integer matches) + count(Float matches)
```

This unification prevents the following bug: a column of transaction amounts like `[100, 42.50, 15, 99.99, 200, 1.5]` would be split 50/50 between Integer and Float. Without pre-unification, neither type reaches the 95% consensus threshold, and the column is incorrectly downgraded to `viz:NominalType`. With unification, the combined numeric count is 100%, which correctly resolves to `viz:QuantitativeType`.

The distinction between Integer and Float is preserved as metadata. After unification:
- If `numericCount > 0` and all numeric matches are Integer → `viz:numericPrecision: "integer"`
- If `numericCount > 0` and any numeric match is Float → `viz:numericPrecision: "float"`

**2d. Consensus Threshold:** For each column, compute the consensus score using the unified type counts:

```
For each effective type T in {Temporal, Boolean, Numeric, Nominal}:
  typeCount[T] = count of cells matching T (where Numeric = Integer + Float)

majorityType = argmax(typeCount)
consensus = typeCount[majorityType] / count(non_empty_cells)
```

- If `consensus >= 0.95` → assign the majority type. If the majority type is Numeric, the assigned `viz:DataType` is `viz:QuantitativeType`.
- If `consensus < 0.95` → assign `viz:NominalType` as the safe fallback AND write an `err:InferenceUncertainty` entity to the graph recording the `fieldName`, all `candidateTypes` with their counts (using unified Numeric, not split Integer/Float), and the `consensusScore`.

**2e. Output:** A canonical `viz:DatasetSchema` JSON-LD graph containing one `viz:DataField` entity per column, each annotated with its inferred `viz:DataType`, field name, normalization flag, and (where applicable) numeric precision and uncertainty references.

### 6.2 Phase 2 — Reasoning & Candidate Generation

SHACL validation is binary. The Reasoner must generate candidate specification subgraphs before validation can occur.

**Shape Registry:** The Reasoner maintains a static registry of all known visualization shapes and their arity signatures:

```
viz:BarChartSpecificationShape   → requires: 1 Nominal, 1 Quantitative
viz:LineChartSpecificationShape  → requires: 1 Temporal, 1 Quantitative
viz:ScatterSpecificationShape    → requires: 2 Quantitative
viz:GroupedBarSpecificationShape → requires: 2 Nominal, 1 Quantitative
```

The arity signature is metadata attached to each shape in the ontology via `viz:requiresFieldType` assertions (see Section 5.3 — Custom Reasoner Directives). It is not inferred — it is declared. Standard SHACL engines safely ignore these assertions.

**Generation Algorithm (Bounded):**

1. **Arity Filtering:** For each registered shape, check whether the `viz:DatasetSchema` contains at least the required number of fields of each required type. Shapes whose arity requirements are not satisfiable are immediately discarded.

2. **Permutation Generation:** For each surviving shape, generate all valid field-to-role assignments. A "role" is a slot in the shape (e.g., `viz:hasGroupBy`, `viz:hasMeasure`). The number of permutations for a shape with arity `(n₁, n₂, ...)` against a schema with `(m₁, m₂, ...)` matching fields is `P(m₁, n₁) × P(m₂, n₂) × ...` where `P(m, n)` is the number of n-permutations of m items.

3. **Complexity Bound:** The Reasoner enforces an absolute upper limit of **500 candidate subgraphs** across all shapes. If the combinatorial space exceeds 500 before exhaustion, the Reasoner applies a heuristic ranking (prefer first-listed columns, prefer simpler chart types) and truncates. A `viz:CandidateTruncation` informational entity is written to the graph noting the total combinatorial space size and the applied limit.

4. **SHACL Validation:** Each candidate subgraph is validated against the corresponding SHACL shape with `sh:closed true`. Only candidates that pass validation are promoted to the output set.

5. **Output:** An array of valid `viz:VisualizationSpecification` JSON-LD subgraphs, each fully typed and ready for user selection.

6. **Empty Result:** If zero candidates survive validation, the Reasoner writes an `err:NoViableCandidate` entity to the graph containing the `viz:DatasetSchema` IRI and the count of shapes evaluated.

### 6.3 Phase 3 — Customization (State Mutation)

1. **Input:** The user selects a candidate `viz:VisualizationSpecification` from the UI.
2. **Mutation:** The user alters visual parameters (title, colors, axis labels). Each UI interaction maps to a JSON-LD triple mutation (e.g., updating `viz:hasTitle`).
3. **Validation Gate:** Every mutation is validated against the SHACL shape before being committed to the state graph. If validation fails, the mutation is rejected and an `err:ValidationFailure` entity is appended to the graph. The UI reads this entity and surfaces the `sh:resultMessage` to the user. The state graph is not modified by the rejected mutation.
4. **State Serialization:** The composite JSON-LD graph (DatasetSchema + VisualizationSpecification + any error entities) is serialized and passed to the state adapter (IndexedDB or filesystem).

### 6.4 Phase 4 — Compilation

**Input:** The fully customized `viz:VisualizationSpecification` JSON-LD graph AND the `proj:` projection graph for the Vega-Lite target.

**6.4.1 Dot-Notation Path Resolution (Normative):**

The `proj:targetPath` values in the projection graph use dot-separated strings (e.g., `"encoding.x"`, `"data.url"`) to denote nested JSON output paths. The compiler MUST implement the following deterministic path resolution algorithm:

```
function setByPath(obj, dotPath, value):
    segments = dotPath.split(".")
    current = obj
    for i = 0 to segments.length - 2:
        key = segments[i]
        if key not in current:
            current[key] = {}
        current = current[key]
    current[segments[segments.length - 1]] = value
```

A conforming compiler MUST NOT treat dot-separated paths as flat keys. The path `"encoding.x"` MUST produce `{"encoding": {"x": ...}}`, NEVER `{"encoding.x": ...}`. Failure to implement recursive path resolution is a specification violation that will produce invalid Vega-Lite output.

**Edge cases:**
- Single-segment paths (e.g., `"mark"`) write directly to the root object.
- If a path segment already exists as a non-object value and a deeper segment is requested, the compiler writes an `err:CompilationFailure` (path collision) and halts.

**6.4.2 Projection Algorithm:**

1. Initialize an empty JSON object as the output AST.
2. Iterate over all `proj:PropertyMapping` and `proj:SubgraphMapping` entries in the projection graph that reference the active shape.
3. For each `proj:PropertyMapping`:
   a. Read the value of `proj:sourceProperty` from the specification graph.
   b. If the value is an IRI and the mapping includes a `proj:iriToValue` table, resolve the IRI to its target string using the table.
   c. Coerce the resolved value to the `proj:targetType`.
   d. Write it to the output AST using the dot-notation path resolver (6.4.1).
4. For each `proj:SubgraphMapping`:
   a. Navigate to the subgraph referenced by `proj:sourceProperty`.
   b. Process each `proj:childMappings` entry as a `PropertyMapping` scoped to the subgraph.
   c. Write the assembled child object to the output AST at the parent's `proj:targetPath`.
5. For mappings marked `proj:optional: true`, skip silently if the source property is absent.
6. For non-optional mappings, if the source property is absent, write an `err:CompilationFailure` entity and halt.

**6.4.3 Output:** A standards-compliant Vega-Lite JSON specification. The compiler appends `"$schema": "https://vega.github.io/schema/vega-lite/v5.json"` to the root object.

### 6.5 Phase 5 — Rendering & Export

1. **Input:** The Vega-Lite JSON specification and the raw CSV data rows.
2. **Canonical Rendering:** The Vega-Lite runtime evaluates the specification and outputs an SVG DOM string. This is the Tier 1 deterministic output. The `viz:VisualizationRenderingProcess` is instantiated ephemerally at this point — it `bfo:realizes` the `viz:VisualizationSpecification` and is not persisted to the state graph (see Section 4.1, Ephemerality Note).
3. **Lossy Export (Optional):** The Integration layer may render the SVG to an HTML5 Canvas and export a PNG via `.toDataURL('image/png')`. This is a Tier 2 environmental projection. In Node.js, the equivalent is `vega-cli` or the `canvas` npm module.

---

## 7. User Interface Contract

This section defines the behavioral requirements for any UI that implements the ECVE pipeline. The UI is an Orchestration adapter (Section 3.3) — it is pluggable and replaceable, but any implementation MUST satisfy these contracts.

### 7.1 Core Interaction Flow

```
┌─────────────┐     ┌──────────────┐     ┌───────────────┐     ┌──────────────┐
│  Drop CSV   │────▶│  Type Review  │────▶│  Chart Select  │────▶│  Customize   │
│  (Phase 1)  │     │  (Phase 1)   │     │  (Phase 2)     │     │  (Phase 3)   │
└─────────────┘     └──────────────┘     └───────────────┘     └──────────────┘
                           │                                           │
                    ┌──────▼──────┐                            ┌──────▼──────┐
                    │  Fix Types  │                            │   Export    │
                    │  (if needed)│                            │  SVG / PNG  │
                    └─────────────┘                            └─────────────┘
```

### 7.2 The CSV Drop Zone

The primary ingestion interface is a drag-and-drop zone. The UI MUST accept:
- Files dragged from the desktop (including files dragged directly from an open Excel/Sheets window if the browser supports it)
- Files selected via a traditional file picker
- Pasted CSV text from the clipboard (for users who copy-paste from a spreadsheet)

The UI MUST display the file name, detected row count, and detected column count immediately upon ingestion, before type inference completes. This gives the user immediate confirmation that their data was received.

### 7.3 Type Review Panel

After Phase 1 completes, the UI MUST display a summary of inferred column types. For each column:
- Column name (from CSV header)
- Inferred type (Quantitative, Nominal, Temporal, Boolean)
- Confidence indicator (the consensus score, displayed as a percentage or color bar)
- Sample values (first 3-5 non-empty values from the column)

If any column has an `err:InferenceUncertainty` attached, the UI MUST highlight that column and offer a manual override control (a dropdown allowing the user to select the correct type). When the user overrides a type, the `viz:DataField` is updated in the state graph, the uncertainty error is resolved, and the Reasoner (Phase 2) re-runs with the corrected schema.

If any column was normalized (Section 6.1, Step 0), the UI SHOULD display a subtle indicator (e.g., "Currency formatting removed") so the user understands why `"$1,234.56"` is being treated as `1234.56`.

### 7.4 Chart Selection Gallery

After Phase 2 completes, the UI presents the valid candidate visualizations as a gallery of thumbnail previews. Each thumbnail is a miniature rendering of the candidate specification applied to a sample of the data (first 20 rows).

The gallery MUST:
- Show only charts that passed SHACL validation. The user cannot select an invalid chart.
- Group candidates by chart type (all bar charts together, all line charts together).
- Pre-select the candidate that the Reasoner ranked highest (first-listed column preference, simplest chart type).

If the Reasoner produced zero candidates (`err:NoViableCandidate`), the UI MUST display a clear explanation: *"We couldn't find a valid chart for this data. This usually means all columns are the same type. Try adding a column with categories or dates."*

### 7.5 Customization Panel

Once the user selects a candidate, the UI presents a customization panel with controls for:
- **Title** (free text input)
- **Colors** (color picker or preset palette)
- **Sort order** (ascending/descending toggle for the grouping axis)
- **Aggregation** (dropdown showing only valid `viz:AggregateOperation` individuals for the selected measure)

Every control maps directly to a JSON-LD triple mutation. Every mutation passes through the Validation Gate (Section 6.3). If a mutation is rejected, the UI displays the SHACL error message in human-readable form and reverts the control to its previous value.

The UI MUST NOT expose controls for axis type, encoding channel, or mark type. These are determined by the ontology and are not user-configurable. This is the key design decision that prevents users from creating semantically invalid charts.

### 7.6 Export

The UI MUST offer two export modes:
- **SVG Download:** The canonical Tier 1 output. Produces a `.svg` file.
- **PNG Download:** The Tier 2 lossy projection. Produces a `.png` file at a configurable DPI (default: 150).

The UI SHOULD also offer:
- **Copy to Clipboard (PNG):** For immediate paste into Excel, PowerPoint, or email.
- **State Export (.jsonld):** For sharing the complete session state with a colleague who can load it into their own ECVE instance and reproduce the exact visualization.

### 7.7 Error Surfacing

The UI reads error entities from the state graph and surfaces them using the following severity mapping:

| Error Class | UI Severity | Behavior |
|---|---|---|
| `err:ParseFailure` | Blocking | Full-screen error with guidance. Pipeline halted. |
| `err:InferenceUncertainty` | Warning | Yellow highlight on affected column. Manual override offered. Pipeline continues. |
| `err:NoViableCandidate` | Informational | Message in chart gallery area. Suggest data modifications. |
| `err:ValidationFailure` | Inline | Red flash on the offending control. SHACL message displayed as tooltip. |
| `err:CompilationFailure` | Blocking | Full-screen error. This indicates an ontology bug — direct user to report. |
| `err:VersionMismatch` | Blocking | Prompt to update ECVE or re-export from current version. |

---

## 8. Spec Test Verification

| Criterion | Status | Notes |
|---|---|---|
| Runs in browser? | Yes | All core logic is standard JavaScript. Vega-Lite runs natively. State is IndexedDB. |
| Runs in Node.js? | Yes | IndexedDB swapped for `fs`. Vega-Lite supports headless SVG output. |
| Requires infrastructure? | No | Zero API calls. Fully self-contained. |
| Structurally deterministic? | Yes | Same CSV + same ontology = same Vega-Lite AST = same SVG string, byte-for-byte. |
| Pixel deterministic? | No | PNG output is a Lossy Environmental Projection (documented, not a bug). |
| SHACL and compiler separated? | Yes | Validation in `viz:` shapes. Projection in separate `proj:` graph. |
| Errors are first-class? | Yes | All failure modes produce `err:` entities in the JSON-LD state graph. |
| JSON-LD canonical? | Yes | Errors, uncertainties, specs, and version metadata are all graph citizens. |
| Ontology versioned? | Yes | `bones:conformsToSpec` on every state graph. |
| Closed-world validation? | Yes | All shapes are `sh:closed true`. |
| Numeric consensus bug? | Fixed | Unification precedes consensus (Section 6.1, Step 2c). |
| Dot-notation compilation? | Specified | Normative path resolver algorithm in Section 6.4.1. |
| Process ephemerality? | Documented | Section 4.1 Ephemerality Note. |
| Reasoner directives? | Documented | Section 5.3 Custom Reasoner Directives. |

---

## 9. Canonical JSON-LD Ontology Graph

This is the normative ontology for ECVE v2.1. It is divided into three documents corresponding to the namespace separation principle.

### 9.1 Validation Ontology (`viz:` + `err:`)

```json
{
  "@context": {
    "cco": "http://www.ontologyrepository.com/CommonCoreOntologies/",
    "bfo": "http://purl.obolibrary.org/obo/",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "owl": "http://www.w3.org/2002/07/owl#",
    "sh": "http://www.w3.org/ns/shacl#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "bones": "https://fnsr.org/ontology/bones/",
    "viz": "https://fnsr.org/ontology/ecve/viz/",
    "err": "https://fnsr.org/ontology/ecve/err/"
  },
  "@graph": [

    {
      "@id": "viz:Ontology",
      "@type": "owl:Ontology",
      "owl:versionIRI": "bones:ecve/2.1",
      "rdfs:label": "ECVE Visualization Ontology v2.1 FINAL"
    },

    {
      "@id": "viz:VisualizationSpecification",
      "@type": "owl:Class",
      "rdfs:subClassOf": "cco:DirectiveInformationContentEntity",
      "rdfs:label": "Visualization Specification",
      "rdfs:comment": "A directive prescribing how a rendering agent must transform data into visual form."
    },
    {
      "@id": "viz:BarChartSpecification",
      "@type": "owl:Class",
      "rdfs:subClassOf": "viz:VisualizationSpecification",
      "rdfs:label": "Bar Chart Specification"
    },
    {
      "@id": "viz:LineChartSpecification",
      "@type": "owl:Class",
      "rdfs:subClassOf": "viz:VisualizationSpecification",
      "rdfs:label": "Line Chart Specification"
    },
    {
      "@id": "viz:ScatterSpecification",
      "@type": "owl:Class",
      "rdfs:subClassOf": "viz:VisualizationSpecification",
      "rdfs:label": "Scatter Plot Specification"
    },

    {
      "@id": "viz:DataEncoding",
      "@type": "owl:Class",
      "rdfs:subClassOf": "cco:DirectiveInformationContentEntity",
      "rdfs:label": "Data Encoding",
      "rdfs:comment": "A directive prescribing the mapping of a data field to a visual channel."
    },

    {
      "@id": "viz:VisualChannel",
      "@type": "owl:Class",
      "rdfs:subClassOf": "cco:InformationContentEntity",
      "rdfs:label": "Visual Channel"
    },
    { "@id": "viz:XPositionChannel", "@type": "owl:Class", "rdfs:subClassOf": "viz:VisualChannel", "rdfs:label": "X-Axis Position Channel" },
    { "@id": "viz:YPositionChannel", "@type": "owl:Class", "rdfs:subClassOf": "viz:VisualChannel", "rdfs:label": "Y-Axis Position Channel" },
    { "@id": "viz:ColorChannel", "@type": "owl:Class", "rdfs:subClassOf": "viz:VisualChannel", "rdfs:label": "Color Channel" },
    { "@id": "viz:SizeChannel", "@type": "owl:Class", "rdfs:subClassOf": "viz:VisualChannel", "rdfs:label": "Size Channel" },

    {
      "@id": "viz:AggregateOperation",
      "@type": "owl:Class",
      "rdfs:subClassOf": "cco:InformationContentEntity",
      "rdfs:label": "Aggregate Operation"
    },
    { "@id": "viz:SumOp", "@type": "viz:AggregateOperation", "rdfs:label": "Sum" },
    { "@id": "viz:MeanOp", "@type": "viz:AggregateOperation", "rdfs:label": "Arithmetic Mean" },
    { "@id": "viz:CountOp", "@type": "viz:AggregateOperation", "rdfs:label": "Count" },
    { "@id": "viz:MinOp", "@type": "viz:AggregateOperation", "rdfs:label": "Minimum" },
    { "@id": "viz:MaxOp", "@type": "viz:AggregateOperation", "rdfs:label": "Maximum" },
    { "@id": "viz:MedianOp", "@type": "viz:AggregateOperation", "rdfs:label": "Median" },

    {
      "@id": "viz:DataType",
      "@type": "owl:Class",
      "rdfs:subClassOf": "cco:InformationContentEntity",
      "rdfs:label": "Data Type"
    },
    { "@id": "viz:QuantitativeType", "@type": "viz:DataType", "rdfs:label": "Quantitative" },
    { "@id": "viz:NominalType", "@type": "viz:DataType", "rdfs:label": "Nominal" },
    { "@id": "viz:TemporalType", "@type": "viz:DataType", "rdfs:label": "Temporal" },
    { "@id": "viz:BooleanType", "@type": "viz:DataType", "rdfs:label": "Boolean" },
    { "@id": "viz:UnknownType", "@type": "viz:DataType", "rdfs:label": "Unknown" },

    {
      "@id": "viz:MarkType",
      "@type": "owl:Class",
      "rdfs:subClassOf": "cco:InformationContentEntity",
      "rdfs:label": "Mark Type"
    },
    { "@id": "viz:BarMark", "@type": "viz:MarkType", "rdfs:label": "Bar" },
    { "@id": "viz:LineMark", "@type": "viz:MarkType", "rdfs:label": "Line" },
    { "@id": "viz:PointMark", "@type": "viz:MarkType", "rdfs:label": "Point" },

    {
      "@id": "viz:VisualizationRenderingProcess",
      "@type": "owl:Class",
      "rdfs:subClassOf": "bfo:BFO_0000015",
      "rdfs:label": "Visualization Rendering Process",
      "rdfs:comment": "The process by which a VisualizationSpecification is realized as a visual artifact. Instances are ephemeral Occurrents — they exist during Phase 5 execution but are NOT serialized into the bones:StateGraph. The state graph captures only Continuants."
    },

    {
      "@id": "viz:realizationAxiom",
      "@type": "owl:Axiom",
      "rdfs:comment": "Every VisualizationRenderingProcess realizes exactly one VisualizationSpecification. This closes the BFO realization pattern: a DirectiveInformationContentEntity (the spec) is realized by the Process it directs.",
      "owl:annotatedSource": "viz:VisualizationRenderingProcess",
      "owl:annotatedProperty": "bfo:BFO_0000055",
      "owl:annotatedTarget": "viz:VisualizationSpecification"
    },

    {
      "@id": "viz:DatasetSchema",
      "@type": "owl:Class",
      "rdfs:subClassOf": "cco:InformationContentEntity",
      "rdfs:label": "Dataset Schema",
      "rdfs:comment": "The structural description of an ingested dataset."
    },
    {
      "@id": "viz:DataField",
      "@type": "owl:Class",
      "rdfs:subClassOf": "cco:InformationContentEntity",
      "rdfs:label": "Data Field"
    },

    {
      "@id": "err:ECVEError",
      "@type": "owl:Class",
      "rdfs:subClassOf": "cco:InformationContentEntity",
      "rdfs:label": "ECVE Error",
      "rdfs:comment": "Base class for all pipeline error entities. Errors are first-class graph citizens, not transient exceptions."
    },
    { "@id": "err:ParseFailure", "@type": "owl:Class", "rdfs:subClassOf": "err:ECVEError", "rdfs:label": "Parse Failure" },
    { "@id": "err:InferenceUncertainty", "@type": "owl:Class", "rdfs:subClassOf": "err:ECVEError", "rdfs:label": "Inference Uncertainty" },
    { "@id": "err:NoViableCandidate", "@type": "owl:Class", "rdfs:subClassOf": "err:ECVEError", "rdfs:label": "No Viable Candidate" },
    { "@id": "err:ValidationFailure", "@type": "owl:Class", "rdfs:subClassOf": "err:ECVEError", "rdfs:label": "Validation Failure" },
    { "@id": "err:CompilationFailure", "@type": "owl:Class", "rdfs:subClassOf": "err:ECVEError", "rdfs:label": "Compilation Failure" },
    { "@id": "err:VersionMismatch", "@type": "owl:Class", "rdfs:subClassOf": "err:ECVEError", "rdfs:label": "Version Mismatch" },

    {
      "@id": "viz:BarChartSpecificationShape",
      "@type": "sh:NodeShape",
      "sh:targetClass": "viz:BarChartSpecification",
      "sh:closed": true,
      "sh:ignoredProperties": [
        { "@id": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" },
        { "@id": "http://www.w3.org/2000/01/rdf-schema#label" },
        { "@id": "http://www.w3.org/2000/01/rdf-schema#comment" }
      ],
      "rdfs:label": "Bar Chart Validation Shape",
      "rdfs:comment": "viz:requiresFieldType is a Custom Reasoner Directive (Section 5.3). Standard SHACL engines safely ignore it.",
      "viz:requiresFieldType": [
        { "viz:typeRequired": { "@id": "viz:NominalType" }, "viz:count": 1 },
        { "viz:typeRequired": { "@id": "viz:QuantitativeType" }, "viz:count": 1 }
      ],
      "sh:property": [
        {
          "sh:path": { "@id": "viz:hasMarkType" },
          "sh:hasValue": { "@id": "viz:BarMark" },
          "sh:minCount": 1,
          "sh:maxCount": 1
        },
        {
          "sh:path": { "@id": "viz:hasDataSource" },
          "sh:nodeKind": "sh:Literal",
          "sh:datatype": "xsd:string",
          "sh:minCount": 1,
          "sh:maxCount": 1
        },
        {
          "sh:path": { "@id": "viz:hasTitle" },
          "sh:datatype": "xsd:string",
          "sh:maxCount": 1
        },
        {
          "sh:path": { "@id": "viz:hasGroupBy" },
          "sh:node": { "@id": "viz:GroupByEncodingShape" },
          "sh:minCount": 1,
          "sh:maxCount": 1
        },
        {
          "sh:path": { "@id": "viz:hasMeasure" },
          "sh:node": { "@id": "viz:MeasureEncodingShape" },
          "sh:minCount": 1,
          "sh:maxCount": 1
        }
      ]
    },

    {
      "@id": "viz:GroupByEncodingShape",
      "@type": "sh:NodeShape",
      "sh:targetClass": "viz:DataEncoding",
      "sh:closed": true,
      "sh:ignoredProperties": [
        { "@id": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" },
        { "@id": "http://www.w3.org/2000/01/rdf-schema#label" },
        { "@id": "http://www.w3.org/2000/01/rdf-schema#comment" }
      ],
      "rdfs:label": "GroupBy Encoding Shape (Nominal → X Axis)",
      "sh:property": [
        {
          "sh:path": { "@id": "viz:mapsToChannel" },
          "sh:hasValue": { "@id": "viz:XPositionChannel" },
          "sh:minCount": 1,
          "sh:maxCount": 1
        },
        {
          "sh:path": { "@id": "viz:field" },
          "sh:datatype": "xsd:string",
          "sh:minCount": 1,
          "sh:maxCount": 1
        },
        {
          "sh:path": { "@id": "viz:orderDirection" },
          "sh:in": {
            "@list": [
              { "@value": "asc", "@type": "xsd:string" },
              { "@value": "desc", "@type": "xsd:string" }
            ]
          },
          "sh:maxCount": 1
        }
      ]
    },

    {
      "@id": "viz:MeasureEncodingShape",
      "@type": "sh:NodeShape",
      "sh:targetClass": "viz:DataEncoding",
      "sh:closed": true,
      "sh:ignoredProperties": [
        { "@id": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" },
        { "@id": "http://www.w3.org/2000/01/rdf-schema#label" },
        { "@id": "http://www.w3.org/2000/01/rdf-schema#comment" }
      ],
      "rdfs:label": "Measure Encoding Shape (Quantitative → Y Axis)",
      "sh:property": [
        {
          "sh:path": { "@id": "viz:mapsToChannel" },
          "sh:hasValue": { "@id": "viz:YPositionChannel" },
          "sh:minCount": 1,
          "sh:maxCount": 1
        },
        {
          "sh:path": { "@id": "viz:field" },
          "sh:datatype": "xsd:string",
          "sh:minCount": 1,
          "sh:maxCount": 1
        },
        {
          "sh:path": { "@id": "viz:aggregate" },
          "sh:in": {
            "@list": [
              { "@id": "viz:SumOp" },
              { "@id": "viz:MeanOp" },
              { "@id": "viz:CountOp" },
              { "@id": "viz:MinOp" },
              { "@id": "viz:MaxOp" },
              { "@id": "viz:MedianOp" }
            ]
          },
          "sh:minCount": 1,
          "sh:maxCount": 1
        }
      ]
    }
  ]
}
```

### 9.2 Projection Graph (`proj:` — Vega-Lite Target)

This graph is stored as a separate JSON-LD document. It references the validation shapes but does not annotate them. The `proj:targetPath` values use dot-notation that the compiler resolves per Section 6.4.1.

```json
{
  "@context": {
    "viz": "https://fnsr.org/ontology/ecve/viz/",
    "proj": "https://fnsr.org/ontology/ecve/proj/",
    "xsd": "http://www.w3.org/2001/XMLSchema#"
  },
  "@graph": [

    {
      "@id": "proj:VegaLiteTarget",
      "@type": "proj:CompilationTarget",
      "proj:targetName": "Vega-Lite",
      "proj:targetVersion": "5.x",
      "proj:outputFormat": "application/json",
      "proj:pathResolution": "dot-notation-recursive",
      "rdfs:comment": "All proj:targetPath values in this graph use dot-separated notation. The compiler MUST resolve them recursively per Section 6.4.1 of the ECVE v2.1 specification."
    },

    {
      "@id": "proj:BarChart_markType",
      "@type": "proj:PropertyMapping",
      "proj:compilationTarget": { "@id": "proj:VegaLiteTarget" },
      "proj:sourceShape": { "@id": "viz:BarChartSpecificationShape" },
      "proj:sourceProperty": { "@id": "viz:hasMarkType" },
      "proj:targetPath": "mark",
      "proj:targetType": "string",
      "proj:iriToValue": [
        { "proj:iri": { "@id": "viz:BarMark" }, "proj:value": "bar" }
      ]
    },
    {
      "@id": "proj:BarChart_dataSource",
      "@type": "proj:PropertyMapping",
      "proj:compilationTarget": { "@id": "proj:VegaLiteTarget" },
      "proj:sourceShape": { "@id": "viz:BarChartSpecificationShape" },
      "proj:sourceProperty": { "@id": "viz:hasDataSource" },
      "proj:targetPath": "data.url",
      "proj:targetType": "string"
    },
    {
      "@id": "proj:BarChart_title",
      "@type": "proj:PropertyMapping",
      "proj:compilationTarget": { "@id": "proj:VegaLiteTarget" },
      "proj:sourceShape": { "@id": "viz:BarChartSpecificationShape" },
      "proj:sourceProperty": { "@id": "viz:hasTitle" },
      "proj:targetPath": "title",
      "proj:targetType": "string",
      "proj:optional": true
    },

    {
      "@id": "proj:BarChart_groupBy",
      "@type": "proj:SubgraphMapping",
      "proj:compilationTarget": { "@id": "proj:VegaLiteTarget" },
      "proj:sourceShape": { "@id": "viz:BarChartSpecificationShape" },
      "proj:sourceProperty": { "@id": "viz:hasGroupBy" },
      "proj:targetPath": "encoding.x",
      "proj:childMappings": [
        {
          "proj:sourceProperty": { "@id": "viz:field" },
          "proj:targetPath": "field",
          "proj:targetType": "string"
        },
        {
          "proj:sourceProperty": { "@id": "viz:mapsToChannel" },
          "proj:targetPath": "type",
          "proj:targetType": "string",
          "proj:iriToValue": [
            { "proj:iri": { "@id": "viz:XPositionChannel" }, "proj:value": "nominal" }
          ]
        },
        {
          "proj:sourceProperty": { "@id": "viz:orderDirection" },
          "proj:targetPath": "sort",
          "proj:targetType": "string",
          "proj:optional": true
        }
      ]
    },

    {
      "@id": "proj:BarChart_measure",
      "@type": "proj:SubgraphMapping",
      "proj:compilationTarget": { "@id": "proj:VegaLiteTarget" },
      "proj:sourceShape": { "@id": "viz:BarChartSpecificationShape" },
      "proj:sourceProperty": { "@id": "viz:hasMeasure" },
      "proj:targetPath": "encoding.y",
      "proj:childMappings": [
        {
          "proj:sourceProperty": { "@id": "viz:field" },
          "proj:targetPath": "field",
          "proj:targetType": "string"
        },
        {
          "proj:sourceProperty": { "@id": "viz:mapsToChannel" },
          "proj:targetPath": "type",
          "proj:targetType": "string",
          "proj:iriToValue": [
            { "proj:iri": { "@id": "viz:YPositionChannel" }, "proj:value": "quantitative" }
          ]
        },
        {
          "proj:sourceProperty": { "@id": "viz:aggregate" },
          "proj:targetPath": "aggregate",
          "proj:targetType": "string",
          "proj:iriToValue": [
            { "proj:iri": { "@id": "viz:SumOp" }, "proj:value": "sum" },
            { "proj:iri": { "@id": "viz:MeanOp" }, "proj:value": "mean" },
            { "proj:iri": { "@id": "viz:CountOp" }, "proj:value": "count" },
            { "proj:iri": { "@id": "viz:MinOp" }, "proj:value": "min" },
            { "proj:iri": { "@id": "viz:MaxOp" }, "proj:value": "max" },
            { "proj:iri": { "@id": "viz:MedianOp" }, "proj:value": "median" }
          ]
        }
      ]
    }
  ]
}
```

### 9.3 Example State Graph (Runtime Instance)

This is what a serialized ECVE session looks like. It demonstrates a fully typed state graph with an inference uncertainty on one column and a normalized currency field.

```json
{
  "@context": {
    "bones": "https://fnsr.org/ontology/bones/",
    "viz": "https://fnsr.org/ontology/ecve/viz/",
    "err": "https://fnsr.org/ontology/ecve/err/",
    "xsd": "http://www.w3.org/2001/XMLSchema#"
  },
  "@id": "bones:ecve/state/session-2026-02-21T14:30:00Z",
  "@type": "bones:StateGraph",
  "bones:conformsToSpec": "bones:ecve/2.1",

  "@graph": [
    {
      "@id": "viz:schema/sales-data",
      "@type": "viz:DatasetSchema",
      "viz:sourceFile": "sales_q4_2025.csv",
      "viz:rowsInspected": 100,
      "viz:totalRows": 2847,
      "viz:hasField": [
        {
          "@id": "viz:field/region",
          "@type": "viz:DataField",
          "viz:fieldName": "Region",
          "viz:hasDataType": { "@id": "viz:NominalType" },
          "viz:consensusScore": 1.0,
          "viz:wasNormalized": false
        },
        {
          "@id": "viz:field/revenue",
          "@type": "viz:DataField",
          "viz:fieldName": "Revenue",
          "viz:hasDataType": { "@id": "viz:QuantitativeType" },
          "viz:numericPrecision": "float",
          "viz:consensusScore": 0.99,
          "viz:wasNormalized": true,
          "rdfs:comment": "Original values contained currency formatting ($1,234.56). Stripped by Pre-Processing Normalizer."
        },
        {
          "@id": "viz:field/code",
          "@type": "viz:DataField",
          "viz:fieldName": "ProductCode",
          "viz:hasDataType": { "@id": "viz:NominalType" },
          "viz:consensusScore": 0.82,
          "viz:wasNormalized": false
        }
      ]
    },

    {
      "@id": "err:uncertainty/code-field",
      "@type": "err:InferenceUncertainty",
      "err:fieldName": "ProductCode",
      "err:candidateTypes": [
        { "err:type": { "@id": "viz:NominalType" }, "err:matchCount": 82 },
        { "err:type": { "@id": "viz:QuantitativeType" }, "err:matchCount": 18 }
      ],
      "err:consensusScore": 0.82,
      "rdfs:comment": "18 of 100 inspected values were pure numeric (product codes like 12345). Unified numeric count (18) did not reach 95% threshold. Fell back to NominalType."
    },

    {
      "@id": "viz:spec/bar-region-revenue",
      "@type": "viz:BarChartSpecification",
      "viz:hasMarkType": { "@id": "viz:BarMark" },
      "viz:hasDataSource": "sales_q4_2025.csv",
      "viz:hasTitle": "Q4 2025 Revenue by Region",
      "viz:hasGroupBy": {
        "@type": "viz:DataEncoding",
        "viz:mapsToChannel": { "@id": "viz:XPositionChannel" },
        "viz:field": "Region",
        "viz:orderDirection": "desc"
      },
      "viz:hasMeasure": {
        "@type": "viz:DataEncoding",
        "viz:mapsToChannel": { "@id": "viz:YPositionChannel" },
        "viz:field": "Revenue",
        "viz:aggregate": { "@id": "viz:SumOp" }
      }
    }
  ]
}
```

This state graph, when passed through the compiler with the Vega-Lite projection graph and the dot-notation path resolver, deterministically produces:

```json
{
  "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
  "mark": "bar",
  "data": { "url": "sales_q4_2025.csv" },
  "title": "Q4 2025 Revenue by Region",
  "encoding": {
    "x": {
      "field": "Region",
      "type": "nominal",
      "sort": "desc"
    },
    "y": {
      "field": "Revenue",
      "type": "quantitative",
      "aggregate": "sum"
    }
  }
}
```

---

## 10. Appendix A — Normative Regex & Normalization Specifications

These specifications are normative. Any conforming ECVE implementation MUST use exactly these patterns. All regexes are ECMA-262 compliant.

### A.1 Temporal

```
/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}(:\d{2})?(\.\d+)?(Z|[+-]\d{2}:?\d{2})?)?$/
```

Matches ISO 8601 date and datetime strings. Does not validate calendar correctness (e.g., `2024-02-30` matches). Calendar validation is deferred to the Vega-Lite runtime.

### A.2 Boolean

```
/^(true|false)$/i
```

Case-insensitive match of the literals `true` and `false`.

### A.3 Integer

```
/^-?\d{1,15}$/
```

Signed integers up to 15 digits. The 15-digit ceiling prevents misclassification of long numeric identifiers (UPCs, credit card numbers, phone numbers) as computable quantities.

### A.4 Float

```
/^-?\d{1,15}\.\d{1,15}$/
```

Signed floating-point numbers with a mandatory decimal point. Scientific notation (`1.5e10`) is explicitly excluded from v2.1 to avoid ambiguity; it may be added in a future version with its own regex priority slot.

### A.5 Nominal

No regex. This is the default fallback. Any cell value that does not match Temporal, Boolean, Integer, or Float is classified as Nominal.

### A.6 Currency/Formatting Stripping Regex (Pre-Processing Normalizer)

Applied per-cell before type inference. The normalizer applies these transformations in order:

**Step 1 — Strip leading currency symbols:**
```
/^[\$€£¥₹₩₽₺₱฿]\s*/
```
Remove the leading currency symbol and any following whitespace.

**Step 2 — Strip thousands separators:**
```
/,(?=\d{3}(?:[,.]|\b))/g
```
Remove commas that are followed by exactly three digits (thousands separator pattern). This correctly transforms `"1,234,567.89"` to `"1234567.89"` without stripping commas in non-numeric contexts.

**Step 3 — Strip trailing percentage signs:**
```
/%$/
```
Remove a trailing `%` character. The resulting numeric value represents the percentage as a raw number (e.g., `"45%"` becomes `"45"`, not `"0.45"`). The `viz:DataField` metadata records `viz:wasPercentage: true` so downstream consumers can interpret the value correctly.

**Normalization is idempotent.** Applying the normalizer twice produces the same result as applying it once. Values that do not match any stripping pattern pass through unchanged.

### A.7 Locale-Aware Date Patterns (Optional Pre-Processing)

These patterns are applied only when the UI provides a `viz:localeHint`. The normalizer attempts to convert matching values to ISO 8601 (`YYYY-MM-DD`).

| Locale | Pattern | Regex | Conversion |
|---|---|---|---|
| `en-US` | MM/DD/YYYY | `/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/` | `$3-$1-$2` (zero-pad) |
| `en-GB` | DD/MM/YYYY | `/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/` | `$3-$2-$1` (zero-pad) |
| `de-DE` | DD.MM.YYYY | `/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/` | `$3-$2-$1` (zero-pad) |
| `ja-JP` | YYYY/MM/DD | `/^(\d{4})\/(\d{1,2})\/(\d{1,2})$/` | `$1-$2-$3` (zero-pad) |

**Ambiguity Rule:** If no locale hint is provided and the date format is ambiguous (e.g., `01/02/2024` could be Jan 2 or Feb 1), the normalizer DOES NOT convert. The value passes through as-is, and the regex cascade classifies it as Nominal. This triggers an `err:InferenceUncertainty` that the UI surfaces as a date format prompt.

**Two-digit year handling:** Two-digit years (e.g., `1/15/25`) are NOT converted. The normalizer requires four-digit years to avoid the century ambiguity problem.

---

## 11. Appendix B — Change Log from v2.0

| Change | Section | Rationale |
|---|---|---|
| **BUGFIX:** Numeric Unification moved before Consensus | 6.1 (Step 2c) | Mixed Integer/Float columns were incorrectly downgraded to Nominal when neither sub-type alone reached 95%. Unifying before consensus fixes this. |
| Dot-notation path resolver formally specified | 6.4.1 | Prevents naive compiler implementations from producing flat keys instead of nested JSON objects. |
| Pre-Processing Normalizer added | 3.1, 6.1 (Step 0) | Handles Excel/spreadsheet export artifacts (currency symbols, thousands separators, locale dates). |
| Process ephemerality documented | 4.1 | Clarifies that `viz:VisualizationRenderingProcess` is an Occurrent not serialized to the state graph. |
| Custom Reasoner Directive documented | 5.3 | Explicitly declares `viz:requiresFieldType` as a non-SHACL extension safely ignored by standard validators. |
| UI Contract section added | 7 | Defines behavioral requirements for any ECVE front-end implementation. |
| Design Philosophy section added | 0 | Articulates the Excel gap, user-first design posture, and CSV round-trip workflow. |
| Currency stripping regex (A.6) | 10 | Normative specification for handling spreadsheet-exported currency formatting. |
| Locale date patterns (A.7) | 10 | Optional conversion table for non-ISO date formats common in spreadsheet exports. |
| `viz:wasNormalized` metadata | 9.3 | State graph records which fields were pre-processed so the UI can inform the user. |
| `proj:pathResolution` declaration | 9.2 | Projection graph self-documents its path resolution strategy. |
| Percentage handling | A.6 | `viz:wasPercentage` metadata preserves semantic context after stripping `%`. |
